<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scanned PDF → Markdown</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 12px; padding: 12px; }
    .grid { display: grid; grid-template-columns: 1.1fr .9fr; gap: 12px; }
    @media (max-width: 1000px) { .grid { grid-template-columns: 1fr; } }
    progress { width: 100%; height: 18px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    #previewWrap { display: grid; place-items: center; background: rgba(127,127,127,.08); border-radius: 12px; padding: 8px; min-height: 240px; }
    canvas { max-width: 100%; height: auto; border-radius: 10px; } */
    .status { white-space: pre-wrap; }
    .ok { color: #2e7d32; }
    .warn { color: #b26a00; }
    .err { color: #c62828; }

    /* Markdown preview */
    #mdPreview { overflow-wrap: anywhere; border: 1px solid dimgrey;}
    #mdPreview table { border-collapse: collapse; }
    #mdPreview td, #mdPreview th { border: 1px solid rgba(127,127,127,.25); padding: 6px 8px; }
    #mdPreview pre { overflow-x: auto; padding: 10px; border-radius: 10px; background: rgba(127,127,127,.08); }
    #mdPreview code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; } */

    /* Empty pages badges */
    .page-badge {
      display: inline-block;
      padding: 4px 10px;
      margin: 4px;
      background: rgba(198, 40, 40, 0.1);
      border: 1px solid rgba(198, 40, 40, 0.3);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #c62828;
      transition: all 0.2s;
    }
    .page-badge:hover {
      background: rgba(198, 40, 40, 0.2);
      border-color: rgba(198, 40, 40, 0.5);
    }

    /* Line numbers for textarea */
    .textarea-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .line-numbers {
      position: absolute;
      left: 0;
      top: 0;
      width: 40px;
      padding: 2px 4px;
      padding-right: 8px;
      background: rgba(127,127,127,0.05);
      border-right: 1px solid rgba(127,127,127,0.2);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      line-height: 19.5px; /* Match textarea line height */
      color: rgba(127,127,127,0.6);
      text-align: right;
      user-select: none;
      pointer-events: none;
      overflow: hidden;
      white-space: pre;
      height: 100%;
    }

    #out {
      padding-left: 54px !important;
      font-size: 13px;
      line-height: 19.5px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #lineNumbersMirror {
      position: absolute;
      visibility: hidden;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 13px;
      line-height: 19.5px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px;
    }

    /* Diff view styles */
    .diff-line {
      padding: 2px 4px;
      margin: 0;
    }
    .diff-line-added {
      color: #22863a;
      border-left: 3px solid #22863a;
    }
    .diff-line-removed {
      color: #cb2431;
      border-left: 3px solid #cb2431;
    }
    .diff-line-unchanged {
      color: var(--text-color);
    }
  </style>
</head>
<body>
  <h2>Scanned PDF → Markdown</h2>

  <div>
    <label>PDF file</label>
    <input id="pdfFile" type="file" accept="application/pdf" />
  </div>

  <div>
    <label>LLM Endpoint</label>
    <input id="endpoint" type="text" placeholder="https://..." /> 
    <div class="input-hint" style="margin-top:6px;">For example https://api.together.xyz/v1/chat/completions</div>
  </div>

  <div>
    <label>API Key (if needed)</label>
    <input id="apiKey" type="password" placeholder="..." />
    <div class="input-hint" style="margin-top:6px;">Uses simple HTTP Bearer auth</div>
  </div>

  <div>
    <label>Model</label>
    <input id="model" type="text" value="Qwen/Qwen3-VL-32B-Instruct" />
    <div class="input-hint" style="margin-top:6px;">Use a vision-capable model.</div>
  </div>

  <div>
    <label>Rendering scale</label>
    <input id="scale" type="text" value="2.0" />
    <div class="input-hint" style="margin-top:6px;">Higher = clearer, bigger images. Tip: 1.5-2.5 is usually fine.</div>
  </div>

  <div>
    <label>Max image dimension (px)</label>
    <input id="maxDim" type="text" value="800" />
    <div class="input-hint" style="margin-top:6px;">Downscales huge pages to reduce payload.</div>
  </div>

  <label>Progress</label>
  <progress id="progress" value="0" max="1"></progress>
  <div id="log" class="status input-hint" style="margin-top:10px; max-height: 200px; overflow-y: scroll; border: 1px solid dimgrey; padding: 20px;"></div>


  <div style="display: flex; flex-direction: row; gap: 20px;">
    <button id="start" class="primary">Start Scan</button>
    <button id="abort" disabled>Stop Scan</button>

    <label style="margin: auto 0;">Rescan Page:</label>
    <input id="rescanPageNum" type="number" min="1" placeholder="Page #" style="width: 100px;" />
    <button id="rescanBtn" disabled>Rescan Page</button>

  </div>

  <div style="display: none;">
    <h3 style="margin-top:0;">Current page preview</h3>
    <div id="previewWrap" style="padding: 20px;"><canvas id="canvas"></canvas></div>
    <div class="input-hint" style="margin-top:8px;">
      The image sent to the LLM is derived from this render (after optional downscaling + JPEG encoding).
    </div>
  </div>

  <div>
    <h3>Extracted Text</h3>
    <div class="textarea-wrapper">
      <div id="lineNumbers" class="line-numbers"></div>
      <textarea id="out" style="padding:0;" rows="18" placeholder="Output will appear here..."></textarea>
      <div id="lineNumbersMirror"></div>
    </div>
  </div>

  <div id="emptyPagesSection">
    <label>Empty Pages</label>
    <div id="emptyPagesList" style="display: grid; grid-template-columns: repeat(10, auto); gap: 10px;"></div>
    <div class="input-hint" style="margin-top: 6px;">Click a page number to quickly Rescan it.</div>
  </div>

  <div style="margin-top: 20px;">
    <h3>Review Text</h3>
    <div style="display: flex; flex-direction: row; gap: 20px; align-items: end;">
      <div>
        <label>Start Line</label>
        <input id="reviewStartLine" type="number" min="1" value="1" style="width: 100px;" />
        <div class="input-hint" style="margin-top:6px;">Review 123 lines starting from this line</div>
      </div>
      <button id="reviewBlockBtn" disabled>Review Block</button>
      <button id="reviewAllBtn" disabled>Review All (Auto)</button>
    </div>
  </div>

  <div id="diffSection" style="display: none; margin-top: 20px;">
    <h3>Review Changes (Lines <span id="diffLineRange"></span>)</h3>
    <div style="margin-bottom: 12px;">
      <div id="diffView" style="border: 1px solid rgba(127,127,127,0.3); border-radius: 8px; padding: 12px; background: #fafafa; max-height: 500px; overflow-y: auto; font-family: ui-monospace, monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap;"></div>
    </div>
    <div style="margin-bottom: 12px;">
      <label>Edit Reviewed Text (optional)</label>
      <textarea id="diffReviewed" rows="8" class="mono" style="width: 100%; background: rgba(200,255,200,0.1);"></textarea>
      <div class="input-hint" style="margin-top: 4px;">You can edit the reviewed text above before applying changes.</div>
    </div>
    <div style="display: flex; gap: 12px;">
      <button id="diffApprove" class="primary">Apply Changes</button>
      <button id="diffRetry">Retry Review</button>
      <button id="diffCancel">Cancel</button>
    </div>
  </div>

  <div>
    <h3>Final Preview</h3>
    <div id="mdPreview"style="max-height: 600px; overflow-y: scroll;"></div>
  </div>

  <a id="download" download="output.md">Download Markdown</a>

  <script type="module">
    import { marked } from "https://cdn.jsdelivr.net/npm/marked@13.0.2/+esm";
    import DOMPurify from "https://cdn.jsdelivr.net/npm/dompurify@3.1.6/+esm";
    import * as pdfjsLib from "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf.mjs";
    import * as Diff from "https://cdn.jsdelivr.net/npm/diff@5.1.0/+esm";

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.4.149/pdf.worker.min.mjs";

    const $ = (id) => document.getElementById(id);

    const pdfFileEl = $("pdfFile");
    const endpointEl  = $("endpoint");
    const apiKeyEl  = $("apiKey");
    const modelEl   = $("model");
    const scaleEl   = $("scale");
    const maxDimEl  = $("maxDim");

    const startBtn  = $("start");
    const abortBtn  = $("abort");
    const rescanBtn  = $("rescanBtn");
    const rescanPageNumEl = $("rescanPageNum");
    const dlLink    = $("download");

    const progEl    = $("progress");
    const logEl     = $("log");
    const outEl     = $("out");
    const lineNumbersEl = $("lineNumbers");
    const lineNumbersMirrorEl = $("lineNumbersMirror");
    const mdPreviewEl = $("mdPreview");
    const emptyPagesSectionEl = $("emptyPagesSection");
    const emptyPagesListEl = $("emptyPagesList");

    const reviewStartLineEl = $("reviewStartLine");
    const reviewBlockBtn = $("reviewBlockBtn");
    const reviewAllBtn = $("reviewAllBtn");
    const diffSectionEl = $("diffSection");
    const diffLineRangeEl = $("diffLineRange");
    const diffViewEl = $("diffView");
    const diffReviewedEl = $("diffReviewed");
    const diffApproveBtn = $("diffApprove");
    const diffRetryBtn = $("diffRetry");
    const diffCancelBtn = $("diffCancel");

    const canvas    = $("canvas");
    const ctx       = canvas.getContext("2d", { alpha: false });

    let abortController = null;
    let currentPdf = null;
    let currentTotalPages = 0;
    let currentReviewBlock = null; // Stores info about the block being reviewed
    let isAutoReviewing = false;

    function log(msg, cls = "") {
      const line = cls ? `<span class="${cls}">${escapeHtml(msg)}</span>` : escapeHtml(msg);
      logEl.innerHTML += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }
    log("Idle");

    function setBusy(busy) {
      startBtn.disabled = busy;
      abortBtn.disabled = !busy;
      pdfFileEl.disabled = busy;
      endpointEl.disabled = busy;
      apiKeyEl.disabled = busy;
      modelEl.disabled = busy;
      scaleEl.disabled = busy;
      maxDimEl.disabled = busy;
      rescanBtn.disabled = busy || !currentPdf;
      rescanPageNumEl.disabled = busy;
    }

    function setProgress(current, total, text) {
      progEl.max = Math.max(total, 1);
      progEl.value = Math.min(current, total);
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function clampNumber(value, { min, max, fallback }) {
      const n = Number(value);
      if (!Number.isFinite(n)) return fallback;
      return Math.min(Math.max(n, min), max);
    }

    function isRetriableStatus(status) {
      return status === 408 || status === 409 || status === 425 || status === 429 || (status >= 500 && status <= 599);
    }

    function parseRetryAfterMs(retryAfterValue) {
      if (!retryAfterValue) return null;
      const seconds = Number(retryAfterValue);
      if (Number.isFinite(seconds) && seconds >= 0) return Math.round(seconds * 1000);

      const dateMs = Date.parse(retryAfterValue);
      if (Number.isFinite(dateMs)) {
        const delta = dateMs - Date.now();
        return delta > 0 ? delta : 0;
      }
      return null;
    }

    function jitter(ms) {
      const factor = 0.75 + Math.random() * 0.5;
      return Math.round(ms * factor);
    }

    async function sleep(ms, signal) {
      if (ms <= 0) return;
      if (signal?.aborted) throw new DOMException("Aborted", "AbortError");

      await new Promise((resolve, reject) => {
        const t = setTimeout(resolve, ms);
        const onAbort = () => {
          clearTimeout(t);
          reject(new DOMException("Aborted", "AbortError"));
        };
        if (signal) signal.addEventListener("abort", onAbort, { once: true });
      });
    }

    function createTimeoutController({ timeoutMs, parentSignal }) {
      const controller = new AbortController();

      const onAbort = () => controller.abort(parentSignal?.reason ?? undefined);
      if (parentSignal) {
        if (parentSignal.aborted) controller.abort(parentSignal.reason ?? undefined);
        else parentSignal.addEventListener("abort", onAbort, { once: true });
      }

      const t = setTimeout(() => controller.abort(new Error(`Timeout after ${timeoutMs}ms`)), timeoutMs);

      return {
        signal: controller.signal,
        cleanup() {
          clearTimeout(t);
          if (parentSignal) parentSignal.removeEventListener("abort", onAbort);
        }
      };
    }

    async function fetchWithTimeoutAndRetry(url, fetchOptions, {
      timeoutMs = 90_000,
      maxRetries = 3,
      baseDelayMs = 600,
      maxDelayMs = 8_000,
      signal,
      onRetry
    } = {}) {
      let lastErr;

      for (let attempt = 1; attempt <= (maxRetries + 1); attempt++) {
        if (signal?.aborted) throw new DOMException("Aborted", "AbortError");

        const { signal: attemptSignal, cleanup } = createTimeoutController({ timeoutMs, parentSignal: signal });

        try {
          const res = await fetch(url, { ...fetchOptions, signal: attemptSignal });

          if (res.ok) return res;

          let detail = "";
          try { detail = await res.text(); } catch {}

          if (!isRetriableStatus(res.status) || attempt > maxRetries) {
            throw new Error(
              `LLM error: ${res.status} ${res.statusText}${detail ? ` — ${detail}` : ""}`
            );
          }

          const retryAfterMs = parseRetryAfterMs(res.headers.get("retry-after"));
          const exp = Math.min(maxDelayMs, baseDelayMs * Math.pow(2, attempt - 1));
          const delayMs = jitter(retryAfterMs ?? exp);

          onRetry?.({ attempt, maxRetries, status: res.status, reason: `HTTP ${res.status}`, delayMs });
          await sleep(delayMs, signal);
        } catch (err) {
          if (err?.name === "AbortError") throw err;

          const isTimeout = String(err?.message || "").toLowerCase().includes("timeout");
          const isNetwork = err instanceof TypeError;

          if (!(isTimeout || isNetwork) || attempt > maxRetries) throw err;

          const exp = Math.min(maxDelayMs, baseDelayMs * Math.pow(2, attempt - 1));
          const delayMs = jitter(exp);

          onRetry?.({ attempt, maxRetries, status: null, reason: isTimeout ? "timeout" : "network error", delayMs });
          await sleep(delayMs, signal);
          lastErr = err;
        } finally {
          cleanup();
        }
      }

      throw lastErr ?? new Error("Request failed after retries.");
    }

    async function readPdfArrayBuffer() {
      const file = pdfFileEl.files?.[0];
      if (file) return await file.arrayBuffer();
      throw new Error("Please choose a PDF file.");
    }

    async function loadPdfFromFile() {
      try {
        const pdfData = await readPdfArrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: pdfData });
        const pdf = await loadingTask.promise;

        currentPdf = pdf;
        currentTotalPages = pdf.numPages;

        rescanBtn.disabled = false;
        rescanPageNumEl.max = currentTotalPages;

        log(`PDF loaded: ${currentTotalPages} page(s). Ready for scanning.`, "ok");
      } catch (err) {
        log(`Error loading PDF: ${err?.message ?? String(err)}`, "err");
        currentPdf = null;
        currentTotalPages = 0;
        rescanBtn.disabled = true;
      }
    }

    function downscaleToMaxDim(srcCanvas, maxDim) {
      const w = srcCanvas.width, h = srcCanvas.height;
      const maxSide = Math.max(w, h);
      if (maxSide <= maxDim) return srcCanvas;

      const ratio = maxDim / maxSide;
      const tw = Math.max(1, Math.round(w * ratio));
      const th = Math.max(1, Math.round(h * ratio));

      const tmp = document.createElement("canvas");
      tmp.width = tw;
      tmp.height = th;

      const tctx = tmp.getContext("2d", { alpha: false });
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = "high";
      tctx.drawImage(srcCanvas, 0, 0, tw, th);
      return tmp;
    }

    async function canvasToJpegDataUrl(c, quality = 0.9) {
      return await new Promise((resolve, reject) => {
        c.toBlob((blob) => {
          if (!blob) return reject(new Error("Failed to encode image."));
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = () => reject(new Error("Failed to read image blob."));
          fr.readAsDataURL(blob);
        }, "image/jpeg", quality);
      });
    }

    function trimEachLine(s) {
      return String(s ?? "").replace(/^[^\S\r\n]+|[^\S\r\n]+$/gm, "");
    }

    // async function reviewPageMarkdownWithLLM({
    //   apiKey,
    //   model,
    //   markdown,
    //   signal,
    //   timeoutMs = 120_000,
    //   maxRetries = 3,
    //   onRetry
    // }) {
    //     return markdown;

    // //   const endpoint = "https://api.together.xyz/v1/chat/completions";

    // //   const system = [
    // //     "You are reviewing Scan output for ONE page of a scanned document.",
    // //     "Correct Scan mistakes and formatting issues while preserving meaning.",
    // //     "Fix Markdown structure: headings, lists, tables, spacing, punctuation, broken words.",
    // //     "Do NOT invent text that is not present; do NOT add commentary.",
    // //     "Remove headers, footers, page numbers, and obvious scanner artifacts.",
    // //     "If uncertain, keep the original text.",
    // //     "Output ONLY the final edited Markdown (no code fences, no extra text)."
    // //   ].join(" ");

    // //   const body = {
    // //     model,
    // //     temperature: 0,
    // //     messages: [
    // //       { role: "system", content: system },
    // //       { role: "user", content: String(markdown ?? "") }
    // //     ]
    // //   };

    // //   const res = await fetchWithTimeoutAndRetry(endpoint, {
    // //     method: "POST",
    // //     headers: {
    // //       "Authorization": `Bearer ${apiKey}`,
    // //       "Content-Type": "application/json"
    // //     },
    // //     body: JSON.stringify(body)
    // //   }, { timeoutMs, maxRetries, signal, onRetry });

    // //   const json = await res.json();
    // //   const content = json?.choices?.[0]?.message?.content ?? "";
    // //   return trimEachLine(content);
    // }

    async function transcribePageImageToMarkdown({
      pageNum,
      endpoint,
      apiKey,
      model,
      dataUrl,
      signal,
      timeoutMs = 90_000,
      maxRetries = 3,
      onRetry
    }) {
      const system = [
        "Transcribe this document page into Markdown. This page is part of a larger document.",
        "Remove headers, footers, page numbers. Ignore images.",
        "The first line may be a header. Do not transcribe headers!",
        "The last line may be a footer. Do not transcribe footers!",
        "Pay close attention to the capitalization of each word.",
        "Some isolated lines or paragraphs may have an unusual capitalization, I want you to preserve that.", 
        "Page numbers may be in the first or last row. Do not transcribe the page number!",
        "Chapter titles should be rendered as first level Markdown headers (like '# Chapter One').",
        "If a word is broken at a line end, remove the dash and put it back together.",
        "If the page contains no text, return this string: '<!-- Empty page -->'.",
        "Never generate markdown fences or any text that's not present in the document page."
      ].join(" ");

      const userText = `Here is page ${pageNum}:`;

      const body = {
        model,
        temperature: 0.1,
        messages: [
          { role: "system", content: system },
          {
            role: "user",
            content: [
              { type: "text", text: userText },
              { type: "image_url", image_url: { url: dataUrl } }
            ]
          }
        ]
      };

      const res = await fetchWithTimeoutAndRetry(endpoint, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      }, { timeoutMs, maxRetries, signal, onRetry });

      const json = await res.json();
      return json?.choices?.[0]?.message?.content ?? "";
    }

    async function reviewTextWithLLM({
      text,
      endpoint,
      apiKey,
      model,
      signal,
      timeoutMs = 90_000,
      maxRetries = 3,
      onRetry
    }) {
      const system = [
        "You are reviewing OCR-extracted text from a document.",
        "Fix any Scan mistakes like character misrecognition, broken words, or formatting errors.",
        "Never delete any comments, even if they are in the middle of a word. For example in the following text:",
        "'beutif-\n\n<!-- Page 45 -->\n\nul', return beutif<!-- Page 45 -->ul' to make the word look unbroken.",
        "Do not add or remove content.",
        "Keep existing markdown formatting intact (headers, lists, tables, etc.).",
        "In some cases, the OCR engine did not merge broken lines into a single line. Fix that.",
        "In some cases, the OCR engine added non existing intentation in the middle of regular text. Remove that.",
        "Occasionally the OCR engine got stuck to all caps for a whole paragraph or more. Fix that by reintroducing normal capitalization.",
        "Titles are not recognized by the OCR engine. Make sure they're all represented as Markdown headings (and don't let the capitalization confuse you).",
        "Tables may have not been recognized by the OCR engine: fix them to render correctly as Markdown tables.",
        "Table of Content and other indices may have not been recognized by the OCR engine: fix them to render ",
        "correctly, with page numbers on the same line as the chapter titles.",
        "If the text looks correct, return it unchanged.",
        "Output ONLY the corrected text, no explanations or markdown fences."
      ].join(" ");

      const body = {
        model,
        temperature: 0,
        messages: [
          { role: "system", content: system },
          { role: "user", content: text }
        ]
      };

      const res = await fetchWithTimeoutAndRetry(endpoint, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      }, { timeoutMs, maxRetries, signal, onRetry });

      const json = await res.json();
      return json?.choices?.[0]?.message?.content ?? "";
    }

    function renderMarkdownPreview(mdText) {
      const rawHtml = marked.parse(mdText || "", { breaks: true });
      const cleanHtml = DOMPurify.sanitize(rawHtml, {
        ALLOWED_TAGS: [
          "a","p","br","strong","em","code","pre","blockquote",
          "ul","ol","li","h1","h2","h3","h4","h5","h6","hr",
          "table","thead","tbody","tr","th","td","span","div"
        ],
        ALLOWED_ATTR: ["href","title"]
      });
      mdPreviewEl.innerHTML = cleanHtml;
    }

    function updateLineNumbers() {
      const lines = outEl.value.split('\n');
      const lineCount = lines.length;

      // Set mirror width to match textarea content area
      const textareaStyles = window.getComputedStyle(outEl);
      const paddingLeft = parseFloat(textareaStyles.paddingLeft);
      const paddingRight = parseFloat(textareaStyles.paddingRight);
      const contentWidth = outEl.clientWidth - paddingLeft - paddingRight;
      lineNumbersMirrorEl.style.width = contentWidth + 'px';

      // Build line numbers accounting for wrapped lines
      let lineNumbersHtml = '';
      const lineHeight = parseFloat(textareaStyles.lineHeight);

      for (let i = 0; i < lineCount; i++) {
        const lineNum = i + 1;
        const lineText = lines[i] || ' '; // Use space for empty lines

        // Render the line in the mirror to measure its height
        lineNumbersMirrorEl.textContent = lineText;
        const lineRenderedHeight = lineNumbersMirrorEl.offsetHeight;

        // Calculate how many visual lines this takes
        const visualLines = Math.max(1, Math.round(lineRenderedHeight / lineHeight));

        // Add the line number for the first visual line
        lineNumbersHtml += lineNum + '\n';

        // Add empty lines for wrapped portions
        for (let j = 1; j < visualLines; j++) {
          lineNumbersHtml += '\n';
        }
      }

      lineNumbersEl.textContent = lineNumbersHtml;

      // Match the padding of the textarea
      lineNumbersEl.style.paddingTop = textareaStyles.paddingTop;
      lineNumbersEl.style.paddingBottom = textareaStyles.paddingBottom;

      // Enable/disable review buttons based on content
      const hasContent = outEl.value.trim().length > 0;
      reviewBlockBtn.disabled = !hasContent;
      reviewAllBtn.disabled = !hasContent;
    }

    function renderDiff(originalText, reviewedText) {
      const diff = Diff.diffTrimmedLines(originalText, reviewedText);
      let html = '';

      diff.forEach((part) => {
        const lines = part.value.split('\n');
        // Remove last empty line if exists
        if (lines[lines.length - 1] === '') lines.pop();

        lines.forEach((line) => {
          let className = 'diff-line';
          let prefix = ' ';

          if (part.added) {
            className += ' diff-line-added';
            prefix = '+';
          } else if (part.removed) {
            className += ' diff-line-removed';
            prefix = '-';
          } else {
            className += ' diff-line-unchanged';
          }

          const escapedLine = escapeHtml(line || ' ');
          html += `<div class="${className}">${prefix} ${escapedLine}</div>`;
        });
      });

      diffViewEl.innerHTML = html;
    }

    function findEmptyPages(mdText) {
      const emptyPages = [];
      const pageRegex = /<!-- Page (\d+) -->\s*([\s\S]*?)(?=<!-- Page \d+ -->|$)/g;
      let match;

      while ((match = pageRegex.exec(mdText)) !== null) {
        const pageNum = parseInt(match[1], 10);
        const content = match[2].trim();

        // Check if the content is the empty page marker
        if (content === '<!-- Empty page -->') {
          emptyPages.push(pageNum);
        }
      }

      return emptyPages;
    }

    function updateEmptyPagesDisplay() {
      const mdText = outEl.value;
      const emptyPages = findEmptyPages(mdText);

      if (emptyPages.length === 0) {
        emptyPagesSectionEl.style.display = "none";
        return;
      }

      emptyPagesSectionEl.style.display = "block";
      emptyPagesListEl.innerHTML = "";

      emptyPages.forEach(pageNum => {
        const badge = document.createElement("button");
        badge.className = "page-badge";
        badge.textContent = `${pageNum}`;
        badge.title = `Click to Rescan page ${pageNum}`;
        badge.addEventListener("click", () => {
          rescanPageNumEl.value = pageNum;
          rescanBtn.click();
        });
        emptyPagesListEl.appendChild(badge);
      });
    }

    async function reviewBlock(startLine) {
      const apiKey = apiKeyEl.value.trim();
      const endpoint = endpointEl.value.trim();
      if (!endpoint) {
        log("Please enter an LLM endpoint.", "err");
        return;
      }

      const model = modelEl.value;
      const lines = outEl.value.split('\n');
      const lineCount = lines.length;

      // Validate start line
      if (startLine < 1 || startLine > lineCount) {
        log(`Invalid start line. Must be between 1 and ${lineCount}.`, "err");
        return;
      }

      // Extract 123 lines starting from startLine
      const blockSize = 123;
      const startIdx = startLine - 1; // Convert to 0-indexed
      const endIdx = Math.min(startIdx + blockSize, lineCount);
      const blockLines = lines.slice(startIdx, endIdx);
      const originalText = blockLines.join('\n');

      // Store current review block info
      currentReviewBlock = {
        startLine,
        endLine: startLine + blockLines.length - 1,
        startIdx,
        endIdx,
        originalText
      };

      // Show diff section
      diffLineRangeEl.textContent = `${currentReviewBlock.startLine}-${currentReviewBlock.endLine}`;
      diffViewEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Reviewing...</div>';
      diffReviewedEl.value = "";
      diffSectionEl.style.display = "block";

      // Disable controls while reviewing
      setBusy(true);
      diffApproveBtn.disabled = true;
      diffRetryBtn.disabled = true;

      try {
        log(`\nReviewing lines ${currentReviewBlock.startLine}-${currentReviewBlock.endLine}...`);

        const reviewedText = await reviewTextWithLLM({
          text: originalText,
          endpoint,
          apiKey,
          model,
          signal: abortController?.signal,
          onRetry: ({ attempt, maxRetries, reason, delayMs }) => {
            log(
              `Review retry ${attempt}/${maxRetries} (${reason}) in ${Math.ceil(delayMs/1000)}s…`,
              "warn"
            );
          }
        });

        // Store reviewed text in the edit textarea
        diffReviewedEl.value = reviewedText;

        // Render the diff view
        renderDiff(originalText, reviewedText);

        // Check if there are any differences
        const hasDifferences = originalText.trim() !== reviewedText.trim();

        if (hasDifferences) {
          log(`Review complete: Changes detected.`, "ok");
          diffApproveBtn.disabled = false;
          diffRetryBtn.disabled = false;
        } else {
          log(`Review complete: No changes needed.`, "ok");

          // Auto-apply if no differences
          if (isAutoReviewing) {
            setTimeout(() => applyReviewChanges(), 500);
          } else {
            diffApproveBtn.disabled = false;
            diffRetryBtn.disabled = false;
          }
        }
      } catch (err) {
        log(`Review error: ${err?.message ?? String(err)}`, "err");
        diffViewEl.innerHTML = `<div style="padding: 20px; color: #c62828;">Error: ${escapeHtml(err?.message ?? String(err))}</div>`;
        diffRetryBtn.disabled = false;
      } finally {
        setBusy(false);
      }
    }

    function applyReviewChanges() {
      if (!currentReviewBlock) return;

      const reviewedText = diffReviewedEl.value;
      const lines = outEl.value.split('\n');

      // Replace the block with reviewed text
      const before = lines.slice(0, currentReviewBlock.startIdx);
      const after = lines.slice(currentReviewBlock.endIdx);
      const newLines = reviewedText.split('\n');

      const newContent = [...before, ...newLines, ...after].join('\n');
      outEl.value = newContent;

      renderMarkdownPreview(newContent);
      updateLineNumbers();
      updateEmptyPagesDisplay();

      log(`Applied changes to lines ${currentReviewBlock.startLine}-${currentReviewBlock.endLine}.`, "ok");

      // Save the end line before clearing currentReviewBlock
      const lastEndLine = currentReviewBlock.endLine;

      // Hide diff section
      diffSectionEl.style.display = "none";
      currentReviewBlock = null;

      // Continue auto-review if active
      if (isAutoReviewing) {
        continueAutoReview(lastEndLine);
      }
    }

    function cancelReview() {
      diffSectionEl.style.display = "none";
      currentReviewBlock = null;
      isAutoReviewing = false;
      setBusy(false);
      log("Review cancelled.", "warn");
    }

    async function reviewAll(startLine = 1) {
      isAutoReviewing = true;
      const lines = outEl.value.split('\n');
      const lineCount = lines.length;

      // Validate start line
      if (startLine < 1 || startLine > lineCount) {
        log(`Invalid start line. Must be between 1 and ${lineCount}.`, "err");
        isAutoReviewing = false;
        return;
      }

      log(`\nStarting auto-review from line ${startLine} in blocks of 123...`, "ok");

      // Start from specified line
      await reviewBlock(startLine);
    }

    async function continueAutoReview(lastEndLine) {
      if (!isAutoReviewing) return;

      const lines = outEl.value.split('\n');
      const lineCount = lines.length;

      // Find next block to review
      const nextStartLine = lastEndLine ? lastEndLine + 1 : 1;

      if (nextStartLine > lineCount) {
        // All done
        isAutoReviewing = false;
        log("\nAuto-review complete!", "ok");
        return;
      }

      // Review next block
      await reviewBlock(nextStartLine);
    }

    async function run() {
      logEl.textContent = "";
      dlLink.style.display = "none";
      dlLink.href = "";

      const apiKey = apiKeyEl.value.trim();
      const endpoint = endpointEl.value.trim();
      if (!endpointEl) throw new Error("Please enter an LLM endpoint.");

      const model = modelEl.value;
      const scale = clampNumber(scaleEl.value, { min: 0.5, max: 6, fallback: 2.0 });
      const maxDim = clampNumber(maxDimEl.value, { min: 512, max: 4096, fallback: 1600 });

      setBusy(true);
      abortController = new AbortController();

      try {
        setProgress(0, 1, "Loading PDF...");
        log("Loading PDF…");

        const pdfData = await readPdfArrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: pdfData });
        const pdf = await loadingTask.promise;

        // Store PDF for Rescan functionality
        currentPdf = pdf;
        currentTotalPages = pdf.numPages;

        const totalPages = pdf.numPages;

        setProgress(0, totalPages, `Loaded PDF. ${totalPages} page(s).`);
        log(`Loaded PDF: ${totalPages} page(s).`, "ok");

        // Enable Rescan button now that PDF is loaded
        rescanPageNumEl.max = totalPages;

        // Check for existing pages in the output
        const existingOutput = outEl.value;
        const existingPageSet = new Set();
        const pageMarkerRegex = /<!-- Page (\d+) -->/g;
        let match;
        while ((match = pageMarkerRegex.exec(existingOutput)) !== null) {
          existingPageSet.add(parseInt(match[1], 10));
        }

        // Determine which pages need to be Scan'd
        const pagesToScan = [];
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
          if (!existingPageSet.has(pageNum)) {
            pagesToScan.push(pageNum);
          }
        }

        if (pagesToScan.length === 0) {
          log("All pages already exist in the output. Nothing to Scan.", "ok");
          setProgress(totalPages, totalPages, "Complete.");

          // Still create download link for existing content
          const final = outEl.value.trim() + "\n";
          const blob = new Blob([final], { type: "text/markdown;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          dlLink.href = url;
          dlLink.download = "output.md";
          dlLink.style.display = "";

          return;
        }

        log(`Found ${existingPageSet.size} existing page(s). Will Scan ${pagesToScan.length} missing page(s).`, "ok");

        // Progress starts at number of existing pages
        let completedPages = existingPageSet.size;
        setProgress(completedPages, totalPages, `Starting Scan: ${completedPages}/${totalPages} pages already done.`);

        for (const pageNum of pagesToScan) {
          if (abortController.signal.aborted) throw new DOMException("Aborted", "AbortError");

          log(`\nPage ${pageNum}/${totalPages}: rendering…`);
          setProgress(completedPages, totalPages, `Rendering page ${pageNum}/${totalPages}…`);

          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale });

          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          await page.render({ canvasContext: ctx, viewport }).promise;

          const uploadCanvas = downscaleToMaxDim(canvas, maxDim);

          setProgress(completedPages, totalPages, `Encoding image ${pageNum}/${totalPages}…`);
          const dataUrl = await canvasToJpegDataUrl(uploadCanvas, 0.9);

          // ----- Scan step -----
          setProgress(completedPages, totalPages, `Scan (page ${pageNum}/${totalPages})…`);
          log(`Page ${pageNum}: Scan…`);

          const mdRaw = await transcribePageImageToMarkdown({
            pageNum,
            endpoint,
            apiKey,
            model,
            dataUrl,
            signal: abortController.signal,
            onRetry: ({ attempt, maxRetries, reason, delayMs, status }) => {
              log(
                `Page ${pageNum} Scan: retry ${attempt}/${maxRetries} (${reason}${status ? ` ${status}` : ""}) in ${Math.ceil(delayMs/1000)}s…`,
                "warn"
              );
            }
          });

          const cleaned = trimEachLine((mdRaw || "").trim()) || " ";

          // Insert the page into the output at the correct position
          const currentOutput = outEl.value;
          const pageMarkerStart = `<!-- Page ${pageNum} -->`;

          if (!currentOutput.trim()) {
            // Empty output - just insert the page
            outEl.value = `\n${pageMarkerStart}\n${cleaned}\n`;
          } else {
            // Find where to insert this page
            const pageMarkerRegex = /<!-- Page (\d+) -->/g;
            const existingPages = [];
            let m;
            while ((m = pageMarkerRegex.exec(currentOutput)) !== null) {
              existingPages.push({
                num: parseInt(m[1], 10),
                index: m.index
              });
            }

            if (existingPages.length === 0) {
              // No page markers at all - append
              outEl.value = currentOutput + `\n${pageMarkerStart}\n${cleaned}\n`;
            } else {
              // Find the right position to insert
              existingPages.sort((a, b) => a.num - b.num);

              let insertIndex = -1;
              for (let i = 0; i < existingPages.length; i++) {
                if (pageNum < existingPages[i].num) {
                  insertIndex = existingPages[i].index;
                  break;
                }
              }

              if (insertIndex === -1) {
                // Insert after the last page
                outEl.value = currentOutput + `\n${pageMarkerStart}\n${cleaned}\n`;
              } else {
                // Insert before the found page
                const before = currentOutput.substring(0, insertIndex);
                const after = currentOutput.substring(insertIndex);
                outEl.value = before + `\n${pageMarkerStart}\n${cleaned}\n` + after;
              }
            }
          }

          completedPages++;
          renderMarkdownPreview(outEl.value);
          updateEmptyPagesDisplay();

          log(`Page ${pageNum}: Scan done. (${cleaned.length} chars)`, "ok");
          setProgress(completedPages, totalPages, `Done ${completedPages}/${totalPages}…`);
        }

        // Final cleanup and download link
        const final = outEl.value.trim() + "\n";
        outEl.value = final;
        renderMarkdownPreview(final);
        updateEmptyPagesDisplay();

        const blob = new Blob([final], { type: "text/markdown;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        dlLink.href = url;
        dlLink.download = "output.md";

        log("\nScan complete. Download is ready.", "ok");
        setProgress(totalPages, totalPages, "Complete.");
        dlLink.style.display = "";
      } catch (err) {
        if (err?.name === "AbortError") {
          log("\nAborted by user.", "warn");
          setProgress(progEl.value, progEl.max, "Aborted.");

          const partial = (outEl.value || "").trim() + "\n";
          const blob = new Blob([partial], { type: "text/markdown;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          dlLink.href = url;
          dlLink.download = "output.md";
        } else {
          log(`\nError: ${err?.message ?? String(err)}`, "err");
          setProgress(progEl.value, progEl.max, "Error.");
        }
      } finally {
        abortController = null;
        setBusy(false);
      }
    }

    async function rescanSinglePage() {
      const pageNum = parseInt(rescanPageNumEl.value, 10);

      if (!currentPdf) {
        log("No PDF loaded. Please run Scan first.", "err");
        return;
      }

      if (!Number.isInteger(pageNum) || pageNum < 1 || pageNum > currentTotalPages) {
        log(`Invalid page number. Enter a number between 1 and ${currentTotalPages}.`, "err");
        return;
      }

      const apiKey = apiKeyEl.value.trim();
      const endpoint = endpointEl.value.trim();
      if (!endpoint) {
        log("Please enter an LLM endpoint.", "err");
        return;
      }

      const model = modelEl.value;
      const scale = clampNumber(scaleEl.value, { min: 0.5, max: 6, fallback: 2.0 });
      const maxDim = clampNumber(maxDimEl.value, { min: 512, max: 4096, fallback: 1600 });

      setBusy(true);
      abortController = new AbortController();

      try {
        log(`\nRescaning page ${pageNum}…`);
        setProgress(0, 1, `Rescaning page ${pageNum}…`);

        // Render the page
        const page = await currentPdf.getPage(pageNum);
        const viewport = page.getViewport({ scale });

        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        await page.render({ canvasContext: ctx, viewport }).promise;

        const uploadCanvas = downscaleToMaxDim(canvas, maxDim);
        const dataUrl = await canvasToJpegDataUrl(uploadCanvas, 0.9);

        // Scan the page
        const mdRaw = await transcribePageImageToMarkdown({
          pageNum,
          endpoint,
          apiKey,
          model,
          dataUrl,
          signal: abortController.signal,
          onRetry: ({ attempt, maxRetries, reason, delayMs, status }) => {
            log(
              `Page ${pageNum} Scan: retry ${attempt}/${maxRetries} (${reason}${status ? ` ${status}` : ""}) in ${Math.ceil(delayMs/1000)}s…`,
              "warn"
            );
          }
        });

        const cleaned = trimEachLine((mdRaw || "").trim()) || " ";

        // Find and replace/insert the content for this page in the output
        const currentOutput = outEl.value;
        const pageMarkerStart = `<!-- Page ${pageNum} -->`;
        const pageMarkerEnd = pageNum < currentTotalPages ? `<!-- Page ${pageNum + 1} -->` : null;

        let newOutput;
        const startIdx = currentOutput.indexOf(pageMarkerStart);

        if (startIdx !== -1) {
          // Page marker exists - replace the content
          let endIdx;
          if (pageMarkerEnd) {
            endIdx = currentOutput.indexOf(pageMarkerEnd, startIdx);
            if (endIdx === -1) endIdx = currentOutput.length;
          } else {
            endIdx = currentOutput.length;
          }

          const before = currentOutput.substring(0, startIdx);
          const after = currentOutput.substring(endIdx);
          const newContent = `${pageMarkerStart}\n${cleaned}${pageMarkerEnd ? '\n' : ''}`;
          newOutput = before + newContent + after;

          log(`Page ${pageNum}: Replaced existing content.`, "ok");
        } else {
          // Page marker doesn't exist - insert at appropriate position
          if (!currentOutput.trim()) {
            // Empty output - just insert the page
            newOutput = `\n${pageMarkerStart}\n${cleaned}\n`;
            log(`Page ${pageNum}: Inserted into empty output.`, "ok");
          } else {
            // Find where to insert this page
            // Extract all existing page numbers
            const pageMarkerRegex = /<!-- Page (\d+) -->/g;
            const existingPages = [];
            let match;
            while ((match = pageMarkerRegex.exec(currentOutput)) !== null) {
              existingPages.push({
                num: parseInt(match[1], 10),
                index: match.index
              });
            }

            if (existingPages.length === 0) {
              // No page markers at all - append
              newOutput = currentOutput + `\n${pageMarkerStart}\n${cleaned}\n`;
              log(`Page ${pageNum}: Appended to output.`, "ok");
            } else {
              // Find the right position to insert
              existingPages.sort((a, b) => a.num - b.num);

              let insertIndex = -1;
              for (let i = 0; i < existingPages.length; i++) {
                if (pageNum < existingPages[i].num) {
                  insertIndex = existingPages[i].index;
                  break;
                }
              }

              if (insertIndex === -1) {
                // Insert after the last page
                newOutput = currentOutput + `\n${pageMarkerStart}\n${cleaned}\n`;
                log(`Page ${pageNum}: Appended after page ${existingPages[existingPages.length - 1].num}.`, "ok");
              } else {
                // Insert before the found page
                const before = currentOutput.substring(0, insertIndex);
                const after = currentOutput.substring(insertIndex);
                newOutput = before + `\n${pageMarkerStart}\n${cleaned}\n` + after;
                log(`Page ${pageNum}: Inserted before page ${existingPages.find(p => p.index === insertIndex).num}.`, "ok");
              }
            }
          }
        }

        outEl.value = newOutput;
        renderMarkdownPreview(newOutput);
        updateEmptyPagesDisplay();

        // Update download link
        const blob = new Blob([newOutput], { type: "text/markdown;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        if (dlLink.href) URL.revokeObjectURL(dlLink.href);
        dlLink.href = url;
        dlLink.download = "output.md";
        dlLink.style.display = "";

        log(`Page ${pageNum}: Rescan done. (${cleaned.length} chars)`, "ok");
        setProgress(1, 1, "Rescan complete.");
      } catch (err) {
        if (err?.name === "AbortError") {
          log("\nAborted by user.", "warn");
        } else {
          log(`\nError: ${err?.message ?? String(err)}`, "err");
        }
      } finally {
        abortController = null;
        setBusy(false);
      }
    }

    pdfFileEl.addEventListener("change", async () => {
      if (pdfFileEl.files?.[0]) {
        await loadPdfFromFile();
      }
    });

    outEl.addEventListener("input", () => {
      renderMarkdownPreview(outEl.value);
      updateEmptyPagesDisplay();
      updateLineNumbers();
    });

    outEl.addEventListener("scroll", () => {
      lineNumbersEl.scrollTop = outEl.scrollTop;
    });

    diffReviewedEl.addEventListener("input", () => {
      if (!currentReviewBlock) return;

      // Re-render diff with the edited text
      renderDiff(currentReviewBlock.originalText, diffReviewedEl.value);
    });

    reviewBlockBtn.addEventListener("click", async () => {
      const startLine = parseInt(reviewStartLineEl.value, 10);
      if (Number.isInteger(startLine) && startLine >= 1) {
        abortController = new AbortController();
        await reviewBlock(startLine);
      } else {
        log("Please enter a valid start line number.", "err");
      }
    });

    reviewAllBtn.addEventListener("click", async () => {
      const startLine = parseInt(reviewStartLineEl.value, 10) || 1;
      abortController = new AbortController();
      await reviewAll(startLine);
    });

    diffApproveBtn.addEventListener("click", () => {
      applyReviewChanges();
    });

    diffRetryBtn.addEventListener("click", async () => {
      if (currentReviewBlock) {
        abortController = new AbortController();
        await reviewBlock(currentReviewBlock.startLine);
      }
    });

    diffCancelBtn.addEventListener("click", () => {
      cancelReview();
    });

    startBtn.addEventListener("click", async () => {
      try { await run(); }
      catch (e) { log(`Error: ${e?.message ?? String(e)}`, "err"); }
    });

    abortBtn.addEventListener("click", () => {
      if (abortController) abortController.abort();
    });

    rescanBtn.addEventListener("click", async () => {
      try { await rescanSinglePage(); }
      catch (e) { log(`Error: ${e?.message ?? String(e)}`, "err"); }
    });

    // Check if a PDF is already selected (e.g., from previous session) and load it
    if (pdfFileEl.files?.[0]) {
      loadPdfFromFile();
    }

    // Check if there's already content in the output and update empty pages display
    if (outEl.value.trim()) {
      updateEmptyPagesDisplay();
      renderMarkdownPreview(outEl.value);
      updateLineNumbers();
    } else {
      // Initialize line numbers even if empty
      updateLineNumbers();
    }

    setProgress(0, 1, "Idle.");
  </script>
</body>
</html>
